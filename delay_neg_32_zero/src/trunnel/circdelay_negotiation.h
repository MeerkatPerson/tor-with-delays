/* circdelay_negotiation.h -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_CIRCDELAY_NEGOTIATION_H
#define TRUNNEL_CIRCDELAY_NEGOTIATION_H

#include <stdint.h>
#include "trunnel.h"

#define N_CELLS 32
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_CIRCDELAY_NEGOTIATE)
struct circdelay_negotiate_st {
  uint32_t delays[N_CELLS];
  uint32_t seed;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct circdelay_negotiate_st circdelay_negotiate_t;
/** Return a newly allocated circdelay_negotiate with all elements set
 * to zero.
 */
circdelay_negotiate_t *circdelay_negotiate_new(void);
/** Release all storage held by the circdelay_negotiate in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void circdelay_negotiate_free(circdelay_negotiate_t *victim);
/** Try to parse a circdelay_negotiate from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated circdelay_negotiate_t. On failure, return -2 if the input
 * appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t circdelay_negotiate_parse(circdelay_negotiate_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * circdelay_negotiate in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t circdelay_negotiate_encoded_len(const circdelay_negotiate_t *obj);
/** Try to encode the circdelay_negotiate from 'input' into the buffer
 * at 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t circdelay_negotiate_encode(uint8_t *output, size_t avail, const circdelay_negotiate_t *input);
/** Check whether the internal state of the circdelay_negotiate in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *circdelay_negotiate_check(const circdelay_negotiate_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int circdelay_negotiate_clear_errors(circdelay_negotiate_t *obj);
/** Return the (constant) length of the array holding the delays field
 * of the circdelay_negotiate_t in 'inp'.
 */
size_t circdelay_negotiate_getlen_delays(const circdelay_negotiate_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * delays of the circdelay_negotiate_t in 'inp'.
 */
uint32_t circdelay_negotiate_get_delays(circdelay_negotiate_t *inp, size_t idx);
/** As circdelay_negotiate_get_delays, but take and return a const
 * pointer
 */
uint32_t circdelay_negotiate_getconst_delays(const circdelay_negotiate_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * delays of the circdelay_negotiate_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int circdelay_negotiate_set_delays(circdelay_negotiate_t *inp, size_t idx, uint32_t elt);
/** Return a pointer to the N_CELLS-element array field delays of
 * 'inp'.
 */
uint32_t * circdelay_negotiate_getarray_delays(circdelay_negotiate_t *inp);
/** As circdelay_negotiate_get_delays, but take and return a const
 * pointer
 */
const uint32_t  * circdelay_negotiate_getconstarray_delays(const circdelay_negotiate_t *inp);
/** Return the value of the seed field of the circdelay_negotiate_t in
 * 'inp'
 */
uint32_t circdelay_negotiate_get_seed(const circdelay_negotiate_t *inp);
/** Set the value of the seed field of the circdelay_negotiate_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int circdelay_negotiate_set_seed(circdelay_negotiate_t *inp, uint32_t val);


#endif
